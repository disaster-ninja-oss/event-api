<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="io.kontur.eventapi.dao.mapper.KonturEventsMapper">

    <insert id="insert" useGeneratedKeys="false">
        INSERT INTO kontur_events (event_id, provider, observation_id)
        VALUES (#{eventId}, #{provider}, #{observationId})
        ON CONFLICT (event_id, observation_id) DO UPDATE
        SET provider = #{provider}
    </insert>

    <select id="getEventByExternalId" resultMap="konturEventDtoMap" >
        SELECT event_id, array_agg(observation_id)::uuid[] AS observation_ids, min(recombined_at) as recombined_at
        FROM kontur_events
        WHERE observation_id IN (
            SELECT observation_id
            FROM normalized_observations
            WHERE external_event_id = #{externalId}
            )
        GROUP BY event_id
    </select>

    <select id="getEventById" resultMap="konturEventDtoMap" >
        SELECT event_id, array_agg(observation_id)::uuid[] AS observation_ids, min(recombined_at) as recombined_at
        FROM kontur_events
        WHERE event_id = #{eventId}
        GROUP BY event_id
    </select>

    <select id="findClosestEventsToObservations" resultMap="konturEventDtoMap">
        with observations as (
            select observation_id, source_updated_at, collected_geography
            from normalized_observations
            where observation_id in
            <foreach item="id" collection="observationIds" separator="," open="(" close=")">
                #{id}
            </foreach>
        ),
        events as (
            select ((
                select ke.event_id
                from kontur_events ke inner join normalized_observations no on ke.observation_id = no.observation_id
                where ke.provider in ('firms.modis-c6', 'firms.suomi-npp-viirs-c2', 'firms.noaa-20-viirs-c2')
                    <if test='eventIds != null'>
                        <foreach item="eventId" collection="eventIds" open="and ke.event_id in (" separator="," close=")">
                            #{eventId}
                        </foreach>
                    </if>
                    and no.source_updated_at between obs.source_updated_at - interval '24 hours'
                        and obs.source_updated_at + interval '24 hours'
                    and ST_DWithin(obs.collected_geography, no.collected_geography, 2000)
                order by st_distance(obs.collected_geography, no.collected_geography)
                limit 1)) as event_id, array_agg(obs.observation_id)::uuid[] as observation_ids
            from observations obs
            group by event_id
        )
        select * from events where event_id is not null
    </select>

    <select id="getEventsForRolloutEpisodes" resultType="java.util.UUID">
        SELECT event_id
        FROM feed_event_status
        WHERE feed_id = #{feedId}
            AND actual is false
        LIMIT 1000;
    </select>

    <select id="getNotComposedEventsCount" resultType="java.lang.Integer">
        SELECT count(*) FROM feed_event_status WHERE NOT actual;
    </select>

    <resultMap id="konturEventDtoMap" type="io.kontur.eventapi.entity.KonturEvent">
        <result property="eventId" column="event_id"/>
        <result property="observationIds" column="observation_ids" typeHandler="io.kontur.eventapi.typehandler.UUIDArrayTypeHandler"/>
        <result property="recombinedAt" column="recombined_at"/>
    </resultMap>
</mapper>